---
title: Hybrid search examples
description: Examples of using hybrid search mode to search memories and document chunks
---

Hybrid search mode searches memories first, then falls back to document chunks when needed. This provides comprehensive results from both structured memories and raw document content.

## Basic hybrid search

Search for information across both memories and document chunks:

<CodeGroup>

```bash cURL
curl -X POST https://api.supermemory.ai/v4/search \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "q": "What are the key features of machine learning?",
    "searchMode": "hybrid",
    "limit": 10,
    "threshold": 0.7
  }'
```

```javascript JavaScript
const response = await fetch('https://api.supermemory.ai/v4/search', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    q: 'What are the key features of machine learning?',
    searchMode: 'hybrid',
    limit: 10,
    threshold: 0.7
  })
});

const data = await response.json();
console.log(data);
```

```python Python
import requests

response = requests.post(
    'https://api.supermemory.ai/v4/search',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'q': 'What are the key features of machine learning?',
        'searchMode': 'hybrid',
        'limit': 10,
        'threshold': 0.7
    }
)

data = response.json()
print(data)
```

</CodeGroup>

### Response

```json
{
  "results": [
    {
      "id": "mem_abc123",
      "memory": "Machine learning key features: pattern recognition, automated learning, predictive modeling",
      "metadata": {
        "category": "ml_concepts",
        "source": "training_notes"
      },
      "updatedAt": "2024-01-15T10:30:00Z",
      "version": 1,
      "rootMemoryId": null,
      "similarity": 0.94,
      "context": {
        "parents": [],
        "children": []
      },
      "documents": [],
      "chunks": []
    },
    {
      "id": "chunk_xyz789",
      "chunk": "Machine learning algorithms can identify patterns in data without being explicitly programmed. Key features include supervised learning, unsupervised learning, and reinforcement learning approaches.",
      "metadata": {
        "source": "ml_textbook.pdf",
        "page": 12
      },
      "updatedAt": "2024-01-14T09:00:00Z",
      "similarity": 0.89,
      "version": 1,
      "context": {
        "parents": [],
        "children": []
      },
      "documents": [
        {
          "id": "doc_123",
          "title": "Introduction to Machine Learning",
          "type": "pdf",
          "createdAt": "2024-01-10T08:00:00Z",
          "updatedAt": "2024-01-14T09:00:00Z"
        }
      ],
      "chunks": []
    }
  ],
  "timing": 245,
  "total": 2
}
```

## Hybrid search with document metadata

Include document information to understand the source of chunk results:

<CodeGroup>

```bash cURL
curl -X POST https://api.supermemory.ai/v4/search \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "q": "neural network architectures",
    "searchMode": "hybrid",
    "limit": 5,
    "threshold": 0.75,
    "include": {
      "documents": true,
      "summaries": true
    }
  }'
```

```javascript JavaScript
const response = await fetch('https://api.supermemory.ai/v4/search', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    q: 'neural network architectures',
    searchMode: 'hybrid',
    limit: 5,
    threshold: 0.75,
    include: {
      documents: true,
      summaries: true
    }
  })
});

const data = await response.json();
```

```python Python
import requests

response = requests.post(
    'https://api.supermemory.ai/v4/search',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'q': 'neural network architectures',
        'searchMode': 'hybrid',
        'limit': 5,
        'threshold': 0.75,
        'include': {
            'documents': True,
            'summaries': True
        }
    }
)

data = response.json()
```

</CodeGroup>

### Response

```json
{
  "results": [
    {
      "id": "chunk_def456",
      "chunk": "Common neural network architectures include feedforward networks, convolutional neural networks (CNNs), and recurrent neural networks (RNNs). Each architecture is optimized for different types of tasks.",
      "metadata": {
        "source": "deep_learning_guide.pdf",
        "chapter": "3"
      },
      "updatedAt": "2024-01-16T14:20:00Z",
      "similarity": 0.91,
      "version": 1,
      "context": {
        "parents": [],
        "children": []
      },
      "documents": [
        {
          "id": "doc_456",
          "title": "Deep Learning Architectures",
          "type": "pdf",
          "metadata": {
            "author": "Dr. Jane Smith",
            "year": 2024
          },
          "summary": "A comprehensive guide to modern deep learning architectures, covering CNNs, RNNs, transformers, and more.",
          "createdAt": "2024-01-15T10:00:00Z",
          "updatedAt": "2024-01-16T14:20:00Z"
        }
      ],
      "chunks": []
    }
  ],
  "timing": 198,
  "total": 1
}
```

## Hybrid search with filtering

Filter results by metadata while using hybrid search:

<CodeGroup>

```bash cURL
curl -X POST https://api.supermemory.ai/v4/search \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "q": "optimization techniques",
    "searchMode": "hybrid",
    "limit": 10,
    "threshold": 0.7,
    "filters": {
      "and": [
        {
          "key": "category",
          "operator": "equals",
          "value": "deep_learning"
        },
        {
          "key": "difficulty",
          "operator": "less_than_or_equal",
          "value": 3
        }
      ]
    }
  }'
```

```javascript JavaScript
const response = await fetch('https://api.supermemory.ai/v4/search', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    q: 'optimization techniques',
    searchMode: 'hybrid',
    limit: 10,
    threshold: 0.7,
    filters: {
      and: [
        {
          key: 'category',
          operator: 'equals',
          value: 'deep_learning'
        },
        {
          key: 'difficulty',
          operator: 'less_than_or_equal',
          value: 3
        }
      ]
    }
  })
});

const data = await response.json();
```

```python Python
import requests

response = requests.post(
    'https://api.supermemory.ai/v4/search',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'q': 'optimization techniques',
        'searchMode': 'hybrid',
        'limit': 10,
        'threshold': 0.7,
        'filters': {
            'and': [
                {
                    'key': 'category',
                    'operator': 'equals',
                    'value': 'deep_learning'
                },
                {
                    'key': 'difficulty',
                    'operator': 'less_than_or_equal',
                    'value': 3
                }
            ]
        }
    }
)

data = response.json()
```

</CodeGroup>

## Hybrid search with reranking

Use reranking to improve result relevance in hybrid search:

<CodeGroup>

```bash cURL
curl -X POST https://api.supermemory.ai/v4/search \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "q": "best practices for model training",
    "searchMode": "hybrid",
    "limit": 10,
    "threshold": 0.7,
    "rerank": true,
    "include": {
      "documents": true,
      "chunks": true
    }
  }'
```

```javascript JavaScript
const response = await fetch('https://api.supermemory.ai/v4/search', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    q: 'best practices for model training',
    searchMode: 'hybrid',
    limit: 10,
    threshold: 0.7,
    rerank: true,
    include: {
      documents: true,
      chunks: true
    }
  })
});

const data = await response.json();
```

```python Python
import requests

response = requests.post(
    'https://api.supermemory.ai/v4/search',
    headers={
        'Authorization': 'Bearer YOUR_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'q': 'best practices for model training',
        'searchMode': 'hybrid',
        'limit': 10,
        'threshold': 0.7,
        'rerank': True,
        'include': {
            'documents': True,
            'chunks': True
        }
    }
)

data = response.json()
```

</CodeGroup>

## Processing hybrid search results

Here's how to handle both memory and chunk results:

```javascript
const response = await fetch('https://api.supermemory.ai/v4/search', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    q: 'machine learning concepts',
    searchMode: 'hybrid',
    limit: 10
  })
});

const data = await response.json();

// Process results based on type
data.results.forEach(result => {
  if (result.memory) {
    // This is a memory result
    console.log('Memory:', {
      id: result.id,
      content: result.memory,
      similarity: result.similarity,
      metadata: result.metadata
    });
  } else if (result.chunk) {
    // This is a chunk result
    console.log('Chunk:', {
      id: result.id,
      content: result.chunk,
      similarity: result.similarity,
      document: result.documents[0]?.title || 'Unknown'
    });
  }
});
```

## When to use hybrid search

Use hybrid search when:

- **Incomplete memories**: Your memories might not cover all relevant information
- **Document-heavy content**: You have large documents that haven't been fully processed into memories
- **Exploratory search**: You want to discover information across all available sources
- **Fallback mechanism**: You want to ensure results even when memories are sparse

Use memories-only search when:

- **Structured data**: You only want curated, structured memory entries
- **Performance**: You need the fastest possible search (hybrid adds ~50-100ms)
- **Memory-first approach**: Your application relies primarily on memories

## Best practices

1. **Set appropriate thresholds**: Use higher thresholds (0.75-0.85) for hybrid search to ensure quality
2. **Include document metadata**: Always include documents to understand chunk sources
3. **Handle both result types**: Check for `memory` or `chunk` fields in your code
4. **Use reranking for quality**: Enable reranking when result quality is critical
5. **Filter appropriately**: Use filters to narrow down results from both sources
6. **Monitor performance**: Hybrid search is slightly slower due to parallel chunk search

## Related

<CardGroup cols={2}>
  <Card title="Memory search" icon="brain" href="/search/examples/memory-search">
    Examples of memories-only search
  </Card>
  <Card title="Parameters" icon="sliders" href="/search/parameters">
    All search parameters
  </Card>
  <Card title="Response schema" icon="brackets-curly" href="/search/response-schema">
    Understanding responses
  </Card>
  <Card title="Filtering" icon="filter" href="/search/filtering">
    Advanced filtering
  </Card>
</CardGroup>
